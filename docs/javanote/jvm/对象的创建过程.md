# 对象的创建过程

面试官：类加载过程，你之前给我讲过，那么创建对象的过程你知道吗？

我：我似乎知道。

![Java创建对象的过程](https://gitee.com/dreamcater/blog-img/raw/master/uPic/Java创建对象的过程-fC0wRb.png)

## 类加载检查

虚拟机遇到一条 **new** 指令时，首先将去检查这个指令的参数**是否能在常量池中定位到这个类的符号引用**，并且检查这个符号引用代表的**类是否已被加载过**、**解析和初始化过**。如果没有，那必须先执行相应的类加载过程。

## 分配内存

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

- **指针碰撞**
  - **堆规整（没有内存碎片）**
  - 复制算法
  - GC：Serial、ParNew
- **空闲列表**
  - **堆内存不规整的情况下**
  - 虚拟机会维护一个**列表**，该列表会**记录哪些内存块是可用的**，在分配的时候，找一块儿足够大的内存块来划分给对象实例，最后更新列表激励
  - GC：CMS

- **并发问题**
  - **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
  - **TLAB：** 为**每一个线程预先在 Eden 区分配一块儿内存**，JVM 在给线程中的对象分配内存时，**首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配**

## 初始化零值

内存分配完成后，虚拟机需要将分配到的内存空间都**初始化为零值（不包括对象头）**，这一步操作保证了对象的实例字段在 Java 代码中**可以不赋初始值就直接使用**，程序能访问到这些字段的数据类型所对应的零值。

## 设置对象头

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

## 指向init方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，**方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行**方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## 内存布局

面试官：刚才说了内存布局，给我讲一下

我：好的，内存布局分别为**对象头，实例数据，对其填充**

1. **对象头**

**Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的自身运行时数据**（哈**希码、GC 分代年龄、锁状态标志**等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。

2. **实例数据**

**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。

3. **对齐填充**

**对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

## 句柄的访问方式

面试官：给我讲讲对象的访问方式

我：明白，两种：使用句柄和使用直接指针

1. **句柄**：

![使用句柄-f4Cw9x](https://gitee.com/dreamcater/blog-img/raw/master/uPic/使用句柄-f4Cw9x.png)

如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了**对象实例数据**与**类型数据**各自的具体地址信息；

2. **直接指针**：

![直接指针-8m3HHz](https://gitee.com/dreamcater/blog-img/raw/master/uPic/直接指针-8m3HHz.png)

如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

话说：这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是**稳定**的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 **reference 本身不需要修改**。使用直接指针访问方式最大的好处就是**速度快**，它节省了一次指针定位的时间开销。

